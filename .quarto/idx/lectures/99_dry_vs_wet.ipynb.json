{"title":"EDS 217, Lecture 4: DRY üèú vs. WET üåä","markdown":{"yaml":{"title":"EDS 217, Lecture 4: DRY üèú vs. WET üåä"},"headingText":"DRY Programming","containsRefs":false,"markdown":"\n\n\n\n\n![dry.jpg](assets/dry.jpg)\n\n\n\n\n\n\n\nThe idea of DRY is to **reduce the repetition of code**. \n\n\n## DRY vs. WET\n\n\n\nIf DRY means \"Don't Repeat Yourself\"... then WET means \"Write Every Time\", or \"We Enjoy Typing\"\n\n\nDon't write WET code!\n\n\n\n### How to DRY out your code\n\nWe write DRY code - or we DRY out WET code - through a combination of _abstraction_ and _normalization_.\n\n\n\n## Abstraction\n\nThe \"principle of abstraction\" aims to _reduce duplication of information_ (usually code) in a program whenever it is practical to do so:\n\n\"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\"\n\nBenjamin C. Pierce - [Types and Programming Languages](https://en.wikipedia.org/wiki/Types_and_Programming_Languages)\n\n\n\n### Abstraction Example\n\nThe easiest way to understand abstraction is to see it in action. Here's an example that you are already familiar with; determining the energy emitted by an object as a function of its temperature:\n\n$Q = \\epsilon  \\sigma  T^4$\n\nwhere $\\epsilon$ is an object's emmissivity, $\\sigma$ is the Stefan-Boltzmann constant, and $T$ is temperature in degrees Kelvin. \n\n### Abstraction Example\n\n\nWe might write the following code to determine $Q$:\n\n### Abstraction Example\n\nBut this code is going to get very WET very fast.\n\n### Abstraction Example\n\n\nHere's a DRY version obtained using abstraction:\n\n### Abstraction Summary, Part 1\n\n- We keep our code DRY by using _abstraction_. In addition to functions, python also provides `Classes` as another important way to create abstractions. \n\n- **Functions** and **Classes** are the subject of this tomorrow's exercise.\n\n\n\n### Abstraction Summary, Part 2\n\n- In general, the process of keeping code DRY through successive layers of abstraction is known as **re-factoring**. \n\n- The _\"Rule of Three\"_ states that you should probably consider refactoring (i.e. adding abstraction) whenever you find your code doing the same thing three times or more.\n\n\n\n## Normalization\n\n\nNormalization is the process of structuring data in order to reduce redundancy and improve integrity. \n\n\n\n## Normalization\n\n\nSome of the key principles of Normalization include:\n\n- All data have a `Primary Key`, which uniquely identifies a record. Usually, in python, this key is called an `Index`.\n- `Atomic` columns, meaning entries contain a single value. This means no _collections_ should appear as elements within a data table. (i.e. \"cells\" in structured data should not contain lists!)\n- No _transitive_ dependencies. This means that there should not be implicit associations between columns within data tables. \n\n\n\n### Primary Keys\n\nThis form of normalization is easy to obtain, as the idea of an `Index` is embedded in almost any Python data structure, and a core component of data structures witin `pandas`, which is the most popular data science library in python (coming next week!).\n\n\n### Primary Keys\n\n\n### Atomic Columns\n\nThe idea of atomic columns is that each element in a data structure should contain a unique value. This requirement is harder to obtain and you will sometimes violate it.\n\n\n### Atomic Columns\n\nThe idea of atomic columns is that each element in a data structure should contain a unique value. This requirement is harder to obtain and you will sometimes violate it.\n\n\n### Transitive  Dependencies\n\nThe idea of transitive dependencies is the inclusion of multiple associated attributes within the same data structure. \n\n- Transitive dependencies make _updating_ data very difficult, but they can be helpful in _analyzying_ data. \n\n- So we should only introduce them in data that we will not be editing. \n\nUsually environmental data, and especially timeseries, are rarely modified after creation. So we don't need to worry as much about these dependencies.\n\nFor example, contrast a data record of \"temperatures through time\" to a data record of \"user contacts in a social network\".\n\n\n### Transitive  Dependencies\n\nThe idea of transitive dependencies is the inclusion of multiple associated attributes within the same data structure. \n\n\n### Normalization Summary\n\nIn general, for data analysis, basic normalization is handled for you.\n\n- For _read only_ data with fixed associations, a lack of normalization is manageable. \n\n- However, many analyses are easier if you structure your data in ways that are as normalized as possible.\n\n- If you are _collecting_ data then it is important to develop an organization structure that is normalized. \n\n\n\n\n## The End\n","srcMarkdownNoYaml":"\n\n\n\n\n![dry.jpg](assets/dry.jpg)\n\n\n\n# DRY Programming\n\n\n\n\nThe idea of DRY is to **reduce the repetition of code**. \n\n\n## DRY vs. WET\n\n\n\nIf DRY means \"Don't Repeat Yourself\"... then WET means \"Write Every Time\", or \"We Enjoy Typing\"\n\n\nDon't write WET code!\n\n\n\n### How to DRY out your code\n\nWe write DRY code - or we DRY out WET code - through a combination of _abstraction_ and _normalization_.\n\n\n\n## Abstraction\n\nThe \"principle of abstraction\" aims to _reduce duplication of information_ (usually code) in a program whenever it is practical to do so:\n\n\"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\"\n\nBenjamin C. Pierce - [Types and Programming Languages](https://en.wikipedia.org/wiki/Types_and_Programming_Languages)\n\n\n\n### Abstraction Example\n\nThe easiest way to understand abstraction is to see it in action. Here's an example that you are already familiar with; determining the energy emitted by an object as a function of its temperature:\n\n$Q = \\epsilon  \\sigma  T^4$\n\nwhere $\\epsilon$ is an object's emmissivity, $\\sigma$ is the Stefan-Boltzmann constant, and $T$ is temperature in degrees Kelvin. \n\n### Abstraction Example\n\n\nWe might write the following code to determine $Q$:\n\n### Abstraction Example\n\nBut this code is going to get very WET very fast.\n\n### Abstraction Example\n\n\nHere's a DRY version obtained using abstraction:\n\n### Abstraction Summary, Part 1\n\n- We keep our code DRY by using _abstraction_. In addition to functions, python also provides `Classes` as another important way to create abstractions. \n\n- **Functions** and **Classes** are the subject of this tomorrow's exercise.\n\n\n\n### Abstraction Summary, Part 2\n\n- In general, the process of keeping code DRY through successive layers of abstraction is known as **re-factoring**. \n\n- The _\"Rule of Three\"_ states that you should probably consider refactoring (i.e. adding abstraction) whenever you find your code doing the same thing three times or more.\n\n\n\n## Normalization\n\n\nNormalization is the process of structuring data in order to reduce redundancy and improve integrity. \n\n\n\n## Normalization\n\n\nSome of the key principles of Normalization include:\n\n- All data have a `Primary Key`, which uniquely identifies a record. Usually, in python, this key is called an `Index`.\n- `Atomic` columns, meaning entries contain a single value. This means no _collections_ should appear as elements within a data table. (i.e. \"cells\" in structured data should not contain lists!)\n- No _transitive_ dependencies. This means that there should not be implicit associations between columns within data tables. \n\n\n\n### Primary Keys\n\nThis form of normalization is easy to obtain, as the idea of an `Index` is embedded in almost any Python data structure, and a core component of data structures witin `pandas`, which is the most popular data science library in python (coming next week!).\n\n\n### Primary Keys\n\n\n### Atomic Columns\n\nThe idea of atomic columns is that each element in a data structure should contain a unique value. This requirement is harder to obtain and you will sometimes violate it.\n\n\n### Atomic Columns\n\nThe idea of atomic columns is that each element in a data structure should contain a unique value. This requirement is harder to obtain and you will sometimes violate it.\n\n\n### Transitive  Dependencies\n\nThe idea of transitive dependencies is the inclusion of multiple associated attributes within the same data structure. \n\n- Transitive dependencies make _updating_ data very difficult, but they can be helpful in _analyzying_ data. \n\n- So we should only introduce them in data that we will not be editing. \n\nUsually environmental data, and especially timeseries, are rarely modified after creation. So we don't need to worry as much about these dependencies.\n\nFor example, contrast a data record of \"temperatures through time\" to a data record of \"user contacts in a social network\".\n\n\n### Transitive  Dependencies\n\nThe idea of transitive dependencies is the inclusion of multiple associated attributes within the same data structure. \n\n\n### Normalization Summary\n\nIn general, for data analysis, basic normalization is handled for you.\n\n- For _read only_ data with fixed associations, a lack of normalization is manageable. \n\n- However, many analyses are easier if you structure your data in ways that are as normalized as possible.\n\n- If you are _collecting_ data then it is important to develop an organization structure that is normalized. \n\n\n\n\n## The End\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","html-math-method":"katex","toc":true,"css":["styles/activities.css"],"include-before-body":["../header.html"],"output-file":"99_dry_vs_wet.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","toc-location":"left","title":"EDS 217, Lecture 4: DRY üèú vs. WET üåä"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}