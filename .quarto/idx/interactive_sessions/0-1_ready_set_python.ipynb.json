{"title":"Interactive Session 0-1: Getting ready to Python","markdown":{"yaml":{"title":"Interactive Session 0-1: Getting ready to Python"},"headingText":"General Plan","containsRefs":false,"markdown":"\n\n\n\n| [üè† Course Home](../index.ipynb) | [üö¶ EDS217 Vibes](https://eds217-stoplight.herokuapp.com) | [‚û°Ô∏è Next Session](0-2_hello_data_science.ipynb) |\n\n\n![Python Comic](assets/python_environment_2x.png)\n\n\nThere are many ways to set up your local machine to run maintainable python data science code. In addition to the usual need to build your code using version control (e.g. GitHub), any strategy for local computation requires three critical components:\n\n1. A system for managing computing environments to ensure that code runs in a consistent environment.\n1. A system for managing python packages to ensure that code runs with consistent dependencies.\n1. A system for managing python code, which is usually an integrated development environment (IDE) in which editing and running code occur interactively.\n\n\n\n\nIn the past, these three components were often managed separately, but in recent years, there has been a trend towards integrating these components into a single system. For example, the [RStudio IDE](https://rstudio.com) is a single system that manages all three components for R code. Similarly, the [Data Spell IDE](https://www.jetbrains.com/dataspell/) is a single system that manages all three components for python code.\n\nIn this class, we will use a combination of tools to manage these three components. We will use `conda` to manage computing environments and python packages, and we will use [Visual Studio Code](https://code.visualstudio.com) as our IDE.\n\nThese are both very popular tools in the python data science community, and they are both free and open source. However, there are many other options for managing computing environments, python packages, and code execution. We will discuss some of these options below, or you can skip ahead to the [instructions](#instructions) for setting up your local machine.\n\n\n\n## Managing Computing Environments, Libraries, and Dependencies\n\nThere are many options for managing computing environments. These days, a common method is to use `containers`, in which an entire computational system (including processes, memory, disk space) is spun up as an isolated service on your local (or remote) machine. Tools such as [docker](https://www.docker.com) or python-specific [shiv](https://shiv.readthedocs.io/en/latest/) allow for isolated packaging and execution of python programs. Generally, these are better-suited for deployment of code on remote servers, but they can be used locally too. In this class, we're not going to use containers. Instead we will use a more traditional approach to managing computing environments and packages.\n\nMore traditional approaches to managing computing environments and/or packages and dependencies include a suite of diverse tools. Some of these focus only on managing computing environments, while others focus on managing python packages. Some are designed to work with python only (e.g `venv`, `conda`), while others are designed to work with any programming language (e.g `virtualenv`). A few of the most popular options in each category are listed below. \n\n#### Package management tools for python\n`pip` is the standard package management tool for python. It is included with the standard python distribution, and it is the most widely used package management tool for python. However, it does not manage computing environments, so it is not as widely used as other tools below.\n\n`pipx` is a tool developed by [Brett Cannon](https://snarky.ca) that is designed to manage python packages. It has the advantage of being able to install any package hosted on [PyPI](https://pypi.org), as well as packages hosted on github and even packages you‚Äôve made on your local machine. However, it does not manage computing environments, and it does not manage package dependencies.\n\n#### Environment management tools for python \n`virtualenv` is a is a tool to create isolated Python environments. Since Python 3.3, a subset of it has been integrated into the standard library under the `venv`. While `venv` is sufficient to create virtual environments, it does not manage package dependencies, so it is also not as widely used as other tools below. \n\n### Tools that manage both environments and packages\n\n`conda` is a tool developed by [Anaconda](https://anaconda.org) that is designed to manage computing environments. However, it also allows you to install packages, and even install binaries of packages directly without the need for local compilation. It also manages package dependencies, ensuring libraries are inter-operable.\n\n`mamba` is a new tool developed by the [QuantStack](https://quantstack.net) team that is designed to be a drop-in replacement for `conda`. It allows you to create new environments, install packages, and even install binaries of packages directly without the need for local compilation. It also manages package dependencies, ensuring libraries are inter-operable. It is designed to be faster than `conda` and to use fewer resources. It is also designed to be more compatible with `pip` than `conda`. However, it is not as widely used as `conda` and it is not as well-supported by IDEs.\n\n`poetry` is another new tool developed by the [Python Packaging Authority](https://python-poetry.org) team that is designed to manage computing environments and python packages. Advantages of `poetry` include a simplified approach to dependency management and a simplified approach to building and packaging your own code for distribution. Disadvantages include a lack of support for `conda` environments and a lack of support for `pip` packages that are not hosted on [PyPI](https://pypi.org) (although this may change in the future).\n\n\n# 0. Forking, Cloning, & Configuring the course repository\n\nBefore we get started, we need to clone the course repository. This will create a local copy of the course repository on your local machine. We will use this local copy to work through the course materials and you will be able to add your own code to this local copy as you work through the course.\n\n\n\n\n## Forking  the course repository. \n\nTo fork the course repository, you must go to the [course repository](https://github.com/environmental-data-science/eds217_2023) on GitHub and click the \"Fork\" button. This will add the repository to your own GitHub account, and allow you to make changes to the repository without affecting the original repository.\n\n\n\n## Cloning the course repository.\n\nOnce you have forked the repository (added it to your Github account), you need to clone the course repository to create a copy on your local machine.\n\nYou can clone the repo on the github site by going to your local account version of the repository on GitHub:\n\n```html\nhttps://github.com/[your-github-username]/eds217_2023\n```\n\nClick on the green \"Code\" button and copy the URL that appears in the dropdown menu. Then use that url to clone the repository on your local machine:\n\n```bash\ngit clone https://github.com/environmental-data-science/eds217_2023.git\n```\n\nMake sure you put the course repository in a location where you can find it again. For example, you might want to put it in a folder called `dev` or `meds` or `code` or `projects` or something like that. Hopefully you already have organization from your prior work, but if not, now is a good time to start.\n\n\n\n\n## Configuring the course repository.\n\n### Setting Up the Repository for Clean Jupyter Notebooks\n\nTo ensure the integrity and consistency of your Jupyter notebooks, it's helpful to strip outputs before committing them. This keeps notebooks lightweight and avoids accidentally committing potentially sensitive information. It also makes it easier to collaborate on notebooks, because output changes won't be flagged as changes in the Git history. \n\nTo setup the repository for clean Jupyter notebooks, you'll need to add a filter to your local Git configuration. \n\n**Because filters are scripts that run code on your local machine, we do this installation manually, so you can be sure you aren't accidentally running malicious code.**\n\n```bash\ngit config --local filter.strip-notebook-output.clean \"jupyter nbconvert --stdin --stdout --to notebook --ClearOutputPreprocessor.enabled=True\"\ngit config --local filter.strip-notebook-output.smudge cat\ngit config --local filter.strip-notebook-output.required true\n```\n\nThese commands set up a filter only for this repository. They tell Git how to process `.ipynb` files before commit and checkout. \n\n\nWith the filter set up, you can now add and commit Jupyter notebooks to the repository. The filter will automatically strip outputs from the notebooks during the commit process.\n\n\n# 1. Installing and configuring `conda`\n\nThroughout this course, **we will use `conda` for our environment management**. We can access `conda` through the terminal/command line or within a terminal inside an IDE.\n\nHere are detailed instructions for getting conda and our class environment ready for use on your local machine.\n\n## Instructions: [Installing & configuring conda](conda_setup.ipynb)\n\n\n# Managing code and execution (IDEs)\n\nFinally, we come to the tool you will use most when coding on your local computer ‚Äì the Integrated Development Environment, or IDE. The possibilities for IDEs is even more expansive than for either of the other tools. Common python IDEs include:\n\n- [Visual Studio Code](https://code.visualstudio.com)\n- [Jupyter Notebooks](https://jupyter.org)\n- [Jupyter Labs](https://jupyter.org)\n- [Spyder](https://www.spyder-ide.org)\n- [PyCharm](https://www.jetbrains.com/pycharm/)\n- [Data Spell](https://www.jetbrains.com/dataspell/)\n- [Atom](https://atom.io)\n- [RStudio](https://www.rstudio.com)\n\nAny of these would work well for a python data science workflow, but some have more features focused on data science than others. For example, PyCharm is more focused on software engineering, but a new IDE called Data Spell, by the same company (Jet Brains), is squarely centered on data science workflows.\n\nThe best IDE is usually the one you are most familiar with. For that reason, RStudio isn‚Äôt a _terrible_ choice for an IDE. Many data scientists use  `Jupyter` (both Jupyter Notebooks and JupyterLab). However, using a non-browser IDE provides more opportunities for customization and removes a layer of complication required when executing your code.\n\n\n\n#### Python Data Science Editor Usage (Primary Editor)\n![IDE choices](assets/editor_usage.png)\n\n\n\n#### Python Data Science Editor Usage (Secondary Editor)\n![IDE choices](assets/editor_usage_secondary.png)\n\n# 2. Launching Jupyter Notebooks and Testing your Environment\n\nJupyter notebooks are the easiest way to get up-and-running with python. They are also a great tool for formatting code and documentation in the same place. All of the class materials for this course were developed as notebook files. These files aren't pure python, and instead are somewhat similar to `.Rmd` files. However, instead of being encoded in `markdown`, notebooks are encoded as `json` files.\n\nThe `json` format is much more extensible than markdown, but also much harder to edit (it's closer to raw `html` or `xml`). Most python IDEs can render notebook files, but some may support more features than others. To get the most functionality from a notebook (or `.ipynb`) file, it's best to view, edit, and execute the notebook in a `Jupyter` server. Let's start our first server and make sure everything is working well.\n\n## Instruction: [Launching Jupyter and testing your environment](jupyter_setup.ipynb)\n\n\n\n# 3. Installing and Configuring VSCode for Python\n\n**In this class, we will focus on using Visual Studio Code (VSCode) as our IDE.**\n\nThis selection provides you with exposure to the single most popular IDE in the datascience world and also one that is well-supported by the `conda` environment management system. It is also a very popular IDE for software engineering, so you will be able to use it for other courses and projects as well.\n\n## Instructions: [Installing and confuguring VSCode](vscode_setup.ipynb)\n\n","srcMarkdownNoYaml":"\n\n\n\n| [üè† Course Home](../index.ipynb) | [üö¶ EDS217 Vibes](https://eds217-stoplight.herokuapp.com) | [‚û°Ô∏è Next Session](0-2_hello_data_science.ipynb) |\n\n\n![Python Comic](assets/python_environment_2x.png)\n\n## General Plan\n\nThere are many ways to set up your local machine to run maintainable python data science code. In addition to the usual need to build your code using version control (e.g. GitHub), any strategy for local computation requires three critical components:\n\n1. A system for managing computing environments to ensure that code runs in a consistent environment.\n1. A system for managing python packages to ensure that code runs with consistent dependencies.\n1. A system for managing python code, which is usually an integrated development environment (IDE) in which editing and running code occur interactively.\n\n\n\n\nIn the past, these three components were often managed separately, but in recent years, there has been a trend towards integrating these components into a single system. For example, the [RStudio IDE](https://rstudio.com) is a single system that manages all three components for R code. Similarly, the [Data Spell IDE](https://www.jetbrains.com/dataspell/) is a single system that manages all three components for python code.\n\nIn this class, we will use a combination of tools to manage these three components. We will use `conda` to manage computing environments and python packages, and we will use [Visual Studio Code](https://code.visualstudio.com) as our IDE.\n\nThese are both very popular tools in the python data science community, and they are both free and open source. However, there are many other options for managing computing environments, python packages, and code execution. We will discuss some of these options below, or you can skip ahead to the [instructions](#instructions) for setting up your local machine.\n\n\n\n## Managing Computing Environments, Libraries, and Dependencies\n\nThere are many options for managing computing environments. These days, a common method is to use `containers`, in which an entire computational system (including processes, memory, disk space) is spun up as an isolated service on your local (or remote) machine. Tools such as [docker](https://www.docker.com) or python-specific [shiv](https://shiv.readthedocs.io/en/latest/) allow for isolated packaging and execution of python programs. Generally, these are better-suited for deployment of code on remote servers, but they can be used locally too. In this class, we're not going to use containers. Instead we will use a more traditional approach to managing computing environments and packages.\n\nMore traditional approaches to managing computing environments and/or packages and dependencies include a suite of diverse tools. Some of these focus only on managing computing environments, while others focus on managing python packages. Some are designed to work with python only (e.g `venv`, `conda`), while others are designed to work with any programming language (e.g `virtualenv`). A few of the most popular options in each category are listed below. \n\n#### Package management tools for python\n`pip` is the standard package management tool for python. It is included with the standard python distribution, and it is the most widely used package management tool for python. However, it does not manage computing environments, so it is not as widely used as other tools below.\n\n`pipx` is a tool developed by [Brett Cannon](https://snarky.ca) that is designed to manage python packages. It has the advantage of being able to install any package hosted on [PyPI](https://pypi.org), as well as packages hosted on github and even packages you‚Äôve made on your local machine. However, it does not manage computing environments, and it does not manage package dependencies.\n\n#### Environment management tools for python \n`virtualenv` is a is a tool to create isolated Python environments. Since Python 3.3, a subset of it has been integrated into the standard library under the `venv`. While `venv` is sufficient to create virtual environments, it does not manage package dependencies, so it is also not as widely used as other tools below. \n\n### Tools that manage both environments and packages\n\n`conda` is a tool developed by [Anaconda](https://anaconda.org) that is designed to manage computing environments. However, it also allows you to install packages, and even install binaries of packages directly without the need for local compilation. It also manages package dependencies, ensuring libraries are inter-operable.\n\n`mamba` is a new tool developed by the [QuantStack](https://quantstack.net) team that is designed to be a drop-in replacement for `conda`. It allows you to create new environments, install packages, and even install binaries of packages directly without the need for local compilation. It also manages package dependencies, ensuring libraries are inter-operable. It is designed to be faster than `conda` and to use fewer resources. It is also designed to be more compatible with `pip` than `conda`. However, it is not as widely used as `conda` and it is not as well-supported by IDEs.\n\n`poetry` is another new tool developed by the [Python Packaging Authority](https://python-poetry.org) team that is designed to manage computing environments and python packages. Advantages of `poetry` include a simplified approach to dependency management and a simplified approach to building and packaging your own code for distribution. Disadvantages include a lack of support for `conda` environments and a lack of support for `pip` packages that are not hosted on [PyPI](https://pypi.org) (although this may change in the future).\n\n\n# 0. Forking, Cloning, & Configuring the course repository\n\nBefore we get started, we need to clone the course repository. This will create a local copy of the course repository on your local machine. We will use this local copy to work through the course materials and you will be able to add your own code to this local copy as you work through the course.\n\n\n\n\n## Forking  the course repository. \n\nTo fork the course repository, you must go to the [course repository](https://github.com/environmental-data-science/eds217_2023) on GitHub and click the \"Fork\" button. This will add the repository to your own GitHub account, and allow you to make changes to the repository without affecting the original repository.\n\n\n\n## Cloning the course repository.\n\nOnce you have forked the repository (added it to your Github account), you need to clone the course repository to create a copy on your local machine.\n\nYou can clone the repo on the github site by going to your local account version of the repository on GitHub:\n\n```html\nhttps://github.com/[your-github-username]/eds217_2023\n```\n\nClick on the green \"Code\" button and copy the URL that appears in the dropdown menu. Then use that url to clone the repository on your local machine:\n\n```bash\ngit clone https://github.com/environmental-data-science/eds217_2023.git\n```\n\nMake sure you put the course repository in a location where you can find it again. For example, you might want to put it in a folder called `dev` or `meds` or `code` or `projects` or something like that. Hopefully you already have organization from your prior work, but if not, now is a good time to start.\n\n\n\n\n## Configuring the course repository.\n\n### Setting Up the Repository for Clean Jupyter Notebooks\n\nTo ensure the integrity and consistency of your Jupyter notebooks, it's helpful to strip outputs before committing them. This keeps notebooks lightweight and avoids accidentally committing potentially sensitive information. It also makes it easier to collaborate on notebooks, because output changes won't be flagged as changes in the Git history. \n\nTo setup the repository for clean Jupyter notebooks, you'll need to add a filter to your local Git configuration. \n\n**Because filters are scripts that run code on your local machine, we do this installation manually, so you can be sure you aren't accidentally running malicious code.**\n\n```bash\ngit config --local filter.strip-notebook-output.clean \"jupyter nbconvert --stdin --stdout --to notebook --ClearOutputPreprocessor.enabled=True\"\ngit config --local filter.strip-notebook-output.smudge cat\ngit config --local filter.strip-notebook-output.required true\n```\n\nThese commands set up a filter only for this repository. They tell Git how to process `.ipynb` files before commit and checkout. \n\n\nWith the filter set up, you can now add and commit Jupyter notebooks to the repository. The filter will automatically strip outputs from the notebooks during the commit process.\n\n\n# 1. Installing and configuring `conda`\n\nThroughout this course, **we will use `conda` for our environment management**. We can access `conda` through the terminal/command line or within a terminal inside an IDE.\n\nHere are detailed instructions for getting conda and our class environment ready for use on your local machine.\n\n## Instructions: [Installing & configuring conda](conda_setup.ipynb)\n\n\n# Managing code and execution (IDEs)\n\nFinally, we come to the tool you will use most when coding on your local computer ‚Äì the Integrated Development Environment, or IDE. The possibilities for IDEs is even more expansive than for either of the other tools. Common python IDEs include:\n\n- [Visual Studio Code](https://code.visualstudio.com)\n- [Jupyter Notebooks](https://jupyter.org)\n- [Jupyter Labs](https://jupyter.org)\n- [Spyder](https://www.spyder-ide.org)\n- [PyCharm](https://www.jetbrains.com/pycharm/)\n- [Data Spell](https://www.jetbrains.com/dataspell/)\n- [Atom](https://atom.io)\n- [RStudio](https://www.rstudio.com)\n\nAny of these would work well for a python data science workflow, but some have more features focused on data science than others. For example, PyCharm is more focused on software engineering, but a new IDE called Data Spell, by the same company (Jet Brains), is squarely centered on data science workflows.\n\nThe best IDE is usually the one you are most familiar with. For that reason, RStudio isn‚Äôt a _terrible_ choice for an IDE. Many data scientists use  `Jupyter` (both Jupyter Notebooks and JupyterLab). However, using a non-browser IDE provides more opportunities for customization and removes a layer of complication required when executing your code.\n\n\n\n#### Python Data Science Editor Usage (Primary Editor)\n![IDE choices](assets/editor_usage.png)\n\n\n\n#### Python Data Science Editor Usage (Secondary Editor)\n![IDE choices](assets/editor_usage_secondary.png)\n\n# 2. Launching Jupyter Notebooks and Testing your Environment\n\nJupyter notebooks are the easiest way to get up-and-running with python. They are also a great tool for formatting code and documentation in the same place. All of the class materials for this course were developed as notebook files. These files aren't pure python, and instead are somewhat similar to `.Rmd` files. However, instead of being encoded in `markdown`, notebooks are encoded as `json` files.\n\nThe `json` format is much more extensible than markdown, but also much harder to edit (it's closer to raw `html` or `xml`). Most python IDEs can render notebook files, but some may support more features than others. To get the most functionality from a notebook (or `.ipynb`) file, it's best to view, edit, and execute the notebook in a `Jupyter` server. Let's start our first server and make sure everything is working well.\n\n## Instruction: [Launching Jupyter and testing your environment](jupyter_setup.ipynb)\n\n\n\n# 3. Installing and Configuring VSCode for Python\n\n**In this class, we will focus on using Visual Studio Code (VSCode) as our IDE.**\n\nThis selection provides you with exposure to the single most popular IDE in the datascience world and also one that is well-supported by the `conda` environment management system. It is also a very popular IDE for software engineering, so you will be able to use it for other courses and projects as well.\n\n## Instructions: [Installing and confuguring VSCode](vscode_setup.ipynb)\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","html-math-method":"katex","toc":true,"css":["styles/activities.css"],"include-before-body":["../header.html"],"output-file":"0-1_ready_set_python.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","toc-location":"left","title":"Interactive Session 0-1: Getting ready to Python"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}